# 1068 万绿丛中一点红 (20 分)
对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 M×N的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。
### 输入格式：
输入第一行给出三个正整数，分别是 M 和 N（≤ 1000），即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 N 行，每行给出 M 个像素的颜色值，范围在 [ $0$,$2^24$ )内。所有同行数字间用空格或 TAB 分开。
### 输出格式：
在一行中按照<font color="red" size="2px"> (x, y): color 的格式输出所求像素点的位置以及颜色值，其中位置<font color="red" size="2px"> x 和<font color="red" size="2px"> y 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 <font color="red" size="2px">Not Unique；如果这样的点不存在，则输出 <font color="red" size="2px">Not Exist。
### 输入样例 1：
```
8 6 200
0        0        0        0        0        0        0        0
65280    65280    65280    16711479 65280    65280    65280    65280
16711479 65280    65280    65280    16711680 65280    65280    65280
65280    65280    65280    65280    65280    65280    165280   165280
65280    65280    16777015 65280    65280    165280   65480    165280
16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215
```
### 输出样例 1：
```
(5, 3): 16711680
```
### 输入样例 2：
```
4 5 2
0 0 0 0
0 0 3 0
0 0 0 0
0 5 0 0
0 0 0 0
```
### 输出样例 2：
```
Not Unique
```
### 输入样例 3：
```
3 3 5
1 2 3
3 4 5
5 6 7
```
### 输出样例 3：
```
Not Exist
```

### 代码如下：
```c
#include<stdio.h>
#include<math.h>

//数组num用来存储出现的像素点的次数，pixel用来存储像素点 
int num[16777216], pixel[1002][1002];

int main(){
    //输入列数m，行数n，色差，像素点，并记录像素点出现的次数 
    int m, n, tol;
    scanf("%d %d %d", &m, &n, &tol);
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            scanf("%d", &pixel[i][j]);
            num[pixel[i][j]]++;
        }
    }
    
    //count用来计算满足题意的点的个数，row和column分别记录该点的横纵坐标 
    int count = 0, row, column;
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
               //该点只出现过一次且与左上差值大于色差
            if(num[pixel[i][j]] == 1 && abs(pixel[i][j] - pixel[i - 1][j - 1]) > tol 
            && abs(pixel[i][j] - pixel[i - 1][j]) > tol //该点与中上差值大于色差 
            && abs(pixel[i][j] - pixel[i - 1][j + 1]) > tol//该点与右上差值大于色差 
            && abs(pixel[i][j] - pixel[i][j - 1]) > tol//该点与左差值大于色差 
            && abs(pixel[i][j] - pixel[i][j + 1]) > tol//该点与右差值大于色差 
            && abs(pixel[i][j] - pixel[i + 1][j - 1]) > tol//该点与左下差值大于色差 
            && abs(pixel[i][j] - pixel[i + 1][j]) > tol//该点与中下差值大于色差 
            && abs(pixel[i][j] - pixel[i + 1][j + 1]) > tol){//该点与右下差值大于色差 
                count++;
                row = i;
                column = j;
            }
        }
    }
    
    //不存在这样的点输出Not Exist,存在一个输出相应的纵横坐标及相应值，否则输出Not Unique; 
    if(count == 0) printf("Not Exist");
    else if(count == 1) printf("(%d, %d): %ld", column + 1, row + 1, pixel[row][column]);
    else printf("Not Unique");
    
    return 0;
}
```